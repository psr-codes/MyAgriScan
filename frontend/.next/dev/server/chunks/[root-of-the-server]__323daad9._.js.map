{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/kalki299/Coding/dev/college/iot/frontend/app/api/get-description/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\n\ntype RequestBody = {\n  predicted_class?: string\n  name?: string\n}\n\nexport async function POST(request: Request) {\n  try {\n    const body = (await request.json()) as RequestBody\n    const predicted = body.predicted_class || body.name || ''\n    if (!predicted) return NextResponse.json({ error: 'predicted_class required' }, { status: 400 })\n\n    const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY\n    if (!apiKey) {\n      return NextResponse.json({ gemError: { status: 401, detail: 'Gemini API key not configured on server' } }, { status: 200 })\n    }\n\n    const rawModel = process.env.GEMINI_MODEL || 'gemini-2.0-flash'\n    const modelSegment = rawModel.includes('/') ? rawModel : `models/${rawModel}`\n    const url = `https://generativelanguage.googleapis.com/v1beta/${modelSegment}:generateContent`\n\n    // Prompt asks for compact JSON only to make parsing reliable\n    const prompt = `The plant disease detected is: \"${predicted}\". Return ONLY a single, compact JSON object (no markdown or code fences) with keys: description (2-3 sentences), prevention (array of short strings), treatment (array of short strings), tips (array of short strings). Keep answers short and farmer-friendly.`\n\n    const payload = { contents: [{ parts: [{ text: prompt }] }] }\n\n    try {\n      const resp = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', 'X-goog-api-key': apiKey },\n        body: JSON.stringify(payload),\n      })\n\n      if (!resp.ok) {\n        let bodyText = ''\n        try { bodyText = JSON.stringify(await resp.json()) } catch { bodyText = await resp.text() }\n        return NextResponse.json({ gemError: { status: resp.status, detail: bodyText } }, { status: 200 })\n      }\n\n      const data = await resp.json()\n      // extract candidate text\n      let fullText = ''\n      try {\n        const cand = data?.candidates?.[0]\n        if (cand) {\n          if (cand.content && cand.content.parts && Array.isArray(cand.content.parts)) {\n            fullText = cand.content.parts.map((p: any) => p.text || '').join('\\n')\n          } else if (Array.isArray(cand.content)) {\n            const pieces: string[] = []\n            for (const item of cand.content) {\n              if (item.parts && Array.isArray(item.parts)) pieces.push(...item.parts.map((pp: any) => pp.text || ''))\n              else if (typeof item.text === 'string') pieces.push(item.text)\n            }\n            fullText = pieces.join('\\n')\n          } else if (typeof cand.output === 'string') {\n            fullText = cand.output\n          }\n        }\n        if (!fullText && typeof data?.text === 'string') fullText = data.text\n      } catch (e) {\n        console.error('Error extracting Gemini candidate text', e)\n      }\n\n      const stripped = (fullText || '').replace(/```json/g, '').replace(/```/g, '').trim()\n      let parsed: any = null\n      try {\n        parsed = JSON.parse(stripped)\n      } catch (e) {\n        // fallback: try to find first JSON object inside the text\n        const m = stripped.match(/\\{[\\s\\S]*\\}/)\n        if (m) {\n          try { parsed = JSON.parse(m[0]) } catch { parsed = null }\n        }\n      }\n\n      function toArray(v: any): string[] {\n        if (!v && v !== 0) return []\n        if (Array.isArray(v)) return v.map((x) => String(x))\n        if (typeof v === 'string') return v.split(/\\r?\\n|;|\\.|\\u2022/).map(s => s.trim()).filter(Boolean)\n        return [String(v)]\n      }\n\n      if (!parsed) {\n        return NextResponse.json({ description: stripped.substring(0, 400), prevention: [], treatment: [], tips: [], raw: fullText, gemError: { status: 2, detail: 'Failed to parse JSON from Gemini' } }, { status: 200 })\n      }\n\n      const out = {\n        description: String(parsed.description || parsed.desc || parsed.summary || ''),\n        prevention: toArray(parsed.prevention || parsed.prevent || parsed.preventions || []),\n        treatment: toArray(parsed.treatment || parsed.treatments || parsed.remedy || []),\n        tips: toArray(parsed.tips || parsed.tip || parsed.advice || []),\n        raw: fullText || '',\n      }\n\n      return NextResponse.json(out)\n    } catch (e: any) {\n      console.error('Gemini request failed', e)\n      return NextResponse.json({ gemError: { status: 0, detail: String(e?.message || e) } }, { status: 200 })\n    }\n  } catch (err: any) {\n    console.error('get-description error', err)\n    return NextResponse.json({ error: String(err?.message || err) }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":"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"}}]
}